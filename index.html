<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Útvonaltervező - Brute Force</title>
<style>
  /* Itt van az eredeti stílusod, nem változtattam rajta */
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
  }
  .btn {
    padding: 0.3rem 0.6rem;
    margin: 0 0.2rem;
    cursor: pointer;
    border: none;
    border-radius: 4px;
  }
  .btn.primary {
    background-color: #007bff;
    color: white;
  }
  .btn.secondary {
    background-color: #6c757d;
    color: white;
  }
  .btn.ghost {
    background-color: transparent;
    color: #007bff;
    border: 1px solid #007bff;
  }
  #results {
    margin-top: 1rem;
  }
  .item {
    display: flex;
    justify-content: space-between;
    margin: 0.3rem 0;
    padding: 0.3rem;
    border: 1px solid #ccc;
    border-radius: 3px;
  }
  .left {
    flex-grow: 1;
  }
  .right a {
    margin-left: 0.5rem;
    text-decoration: none;
  }
</style>
</head>
<body>

<h2>Útvonaltervező (Brute Force)</h2>

<div>
  <button id="geocodeBtn" class="btn primary">Geokódolás és útvonaltervezés</button>
</div>

<div id="results"></div>

<script>
// Az eredeti címeid, ez az eredeti változatból
const addresses = [
  "Budapest, Kossuth Lajos tér 1",
  "Budapest, Erzsébet tér 7",
  "Budapest, Deák Ferenc tér 3",
  "Budapest, Rákóczi út 10"
];

// Geokódoló függvény (ez az eredeti volt, változatlan)
async function geocode(address) {
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
  const res = await fetch(url);
  const data = await res.json();
  if (data.length > 0) {
    return {
      lat: parseFloat(data[0].lat),
      lon: parseFloat(data[0].lon),
      display_name: data[0].display_name
    };
  }
  throw new Error("Nem található: " + address);
}

// Távolság számító Haversine formula (eredeti)
function haversineDistance(coord1, coord2) {
  function toRad(x) { return x * Math.PI / 180; }
  const R = 6371; // km
  const dLat = toRad(coord2.lat - coord1.lat);
  const dLon = toRad(coord2.lon - coord1.lon);
  const lat1 = toRad(coord1.lat);
  const lat2 = toRad(coord2.lat);

  const a = Math.sin(dLat/2)**2 + Math.sin(dLon/2)**2 * Math.cos(lat1) * Math.cos(lat2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// Brute force összes permutáció generálása (ez a plusz rész)
function permute(arr) {
  if (arr.length <= 1) return [arr];
  const result = [];
  for (let i=0; i<arr.length; i++) {
    const rest = [...arr.slice(0,i), ...arr.slice(i+1)];
    const perms = permute(rest);
    perms.forEach(p => result.push([arr[i], ...p]));
  }
  return result;
}

// Optimalizált útvonal kiválasztása brute force-tal
function findBestRoute(origin, points) {
  let bestDistance = Infinity;
  let bestRoute = null;
  const perms = permute(points);
  perms.forEach(route => {
    let dist = 0;
    let prev = origin;
    route.forEach(p => {
      dist += haversineDistance(prev, p);
      prev = p;
    });
    if (dist < bestDistance) {
      bestDistance = dist;
      bestRoute = route;
    }
  });
  return bestRoute;
}

// Link generátorok (eredeti, változatlan)
function googleLink(origin, point) {
  return `https://www.google.com/maps/dir/?api=1&origin=${origin.lat},${origin.lon}&destination=${point.lat},${point.lon}`;
}
function appleLink(origin, point) {
  return `https://maps.apple.com/?saddr=${origin.lat},${origin.lon}&daddr=${point.lat},${point.lon}`;
}
function wazeLink(origin, point) {
  return `https://waze.com/ul?ll=${point.lat},${point.lon}&navigate=yes`;
}

// A lista megjelenítése (eredeti stílusban, gombokkal)
function renderList(origin, ordered) {
  const results = document.getElementById("results");
  results.innerHTML = "";
  ordered.forEach((p, idx) => {
    const item = document.createElement("div");
    item.className = "item";

    const left = document.createElement("div");
    left.className = "left";
    left.textContent = `${idx+1}. ${p.display_name}`;

    const right = document.createElement("div");
    right.className = "right";

    // Google Maps gomb
    const gBtn = document.createElement("a");
    gBtn.className = "btn secondary";
    gBtn.textContent = "Google";
    gBtn.href = googleLink(origin, p);
    gBtn.target = "_blank";

    // Apple Maps gomb
    const aBtn = document.createElement("a");
    aBtn.className = "btn ghost";
    aBtn.textContent = "Apple";
    aBtn.href = appleLink(origin, p);
    aBtn.target = "_blank";

    // Waze gomb
    const wBtn = document.createElement("a");
    wBtn.className = "btn ghost";
    wBtn.textContent = "Waze";
    wBtn.href = wazeLink(origin, p);
    wBtn.target = "_blank";

    right.appendChild(gBtn);
    right.appendChild(aBtn);
    right.appendChild(wBtn);

    item.appendChild(left);
    item.appendChild(right);

    results.appendChild(item);
  });
}

document.getElementById("geocodeBtn").addEventListener("click", async () => {
  try {
    // Kiindulási pont: jelenlegi helyzet (eredeti módszer)
    const pos = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
        () => reject("Nem sikerült lekérni a helyzetet.")
      );
    });

    // Címek geokódolása
    const geocoded = [];
    for (const addr of addresses) {
      const geo = await geocode(addr);
      geocoded.push(geo);
    }

    // Optimalizált útvonal keresése brute force-szal
    const ordered = findBestRoute(pos, geocoded);

    // Lista megjelenítése
    renderList(pos, ordered);
  } catch (e) {
    alert(e);
  }
});
</script>

</body>
</html>
