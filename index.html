<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gyors C√≠mrendez≈ë & Navig√°ci√≥</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<style>
  :root { --radius: 12px; }
  html, body { height: 100%; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    margin: 0; padding: 16px; background:#f6f7fb; color:#111;
  }
  .app {
    max-width: 900px; margin: 0 auto; background:#fff; padding: 16px;
    border-radius: var(--radius); box-shadow: 0 12px 40px rgba(0,0,0,.08);
  }
  h1 { font-size: 1.25rem; margin: 0 0 8px; }
  p.hint { margin-top: 0; color:#444; font-size: .95rem; }
  textarea {
    width: 100%; min-height: 160px; resize: vertical; padding: 12px;
    border-radius: var(--radius); border:1px solid #d8dbe4; font-size: 1rem;
    box-sizing: border-box;
  }
  .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
  .row > * { flex: 1; }
  .row .tight { flex: 0 0 auto; }
  .btn {
    appearance:none; border:0; border-radius: 10px; padding: 12px 16px;
    background:#111; color:#fff; font-weight: 600; cursor: pointer;
    text-decoration: none; display: inline-block; text-align: center;
  }
  .btn:disabled { background:#ccc; cursor: not-allowed; }
  .btn.secondary { background:#e9ecf4; color:#111; }
  .btn.ghost { background:transparent; color:#111; border:1px solid #d8dbe4; }
  .small { font-size: .9rem; color:#555; }
  .list { margin-top: 16px; }
  .card {
    border:1px solid #e6e8ef; border-radius: 12px; padding: 12px; margin: 8px 0;
    display:flex; gap: 12px; align-items: center; justify-content: space-between;
  }
  .addr { font-weight: 600; }
  .muted { color:#666; font-size: .9rem; }
  .right { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; }
  details { margin-top: 10px; }
  kbd { background:#f3f5fb; border:1px solid #e4e7f0; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
  .foot { margin-top: 16px; color:#666; font-size:.9rem; }
  .pill { background:#f2f5ff; border:1px solid #dbe3ff; color:#1b3ea3; padding:4px 8px; border-radius:999px; font-size:.8rem; }
  select { width:100%; padding:10px; border-radius:10px; border:1px solid #d8dbe4; box-sizing: border-box; }
  .error { color: #d32f2f; background: #ffebee; padding: 12px; border-radius: var(--radius); margin: 8px 0; }
  .success { color: #2e7d32; background: #e8f5e8; padding: 12px; border-radius: var(--radius); margin: 8px 0; }
  .loading { color: #1976d2; background: #e3f2fd; padding: 12px; border-radius: var(--radius); margin: 8px 0; }
  @media (max-width: 600px) {
    .row { flex-direction: column; align-items: stretch; }
    .right { justify-content: center; }
  }
</style>
</head>
<body>
  <div class="app">
    <h1>Gyors C√≠mrendez≈ë & Navig√°ci√≥</h1>
    <p class="hint">√çrj be <b>egy c√≠met soronk√©nt</b>. Megk√©rem a telefonod helyzet√©t, geok√≥dolom a c√≠meket, sorba rakom a <b>hozz√°d m√©rt</b> t√°vols√°g szerint, √©s egy koppint√°ssal megnyitom a navig√°ci√≥t.</p>

    <label for="addresses" class="pill">C√≠mek (egy sor = egy c√≠m)</label>
    <textarea id="addresses" placeholder="Pl.&#10;Kossuth Lajos utca 5, Szeged&#10;Dugonics t√©r 1, Szeged&#10;R√°k√≥czi √∫t 12, Szeged"></textarea>

    <div class="row" style="margin-top:12px">
      <div>
        <label for="app">Navig√°ci√≥s app</label><br/>
        <select id="app">
          <option value="apple">Apple Maps (iPhone aj√°nlott)</option>
          <option value="google">Google Maps</option>
          <option value="waze">Waze</option>
        </select>
      </div>
    </div>

    <details>
      <summary>Halad√≥ be√°ll√≠t√°sok</summary>
      <div style="margin-top:8px" class="small">
        Geok√≥dol√°s: <b>Nominatim (OpenStreetMap)</b>. Kis list√°khoz megb√≠zhat√≥. Ne k√ºldj <b>m√°sodpercenk√©nt 1</b> k√©r√©sn√©l t√∂bbet. T√∂megesen haszn√°land√≥ esetben aj√°nlott saj√°t kulcsos szolg√°ltat√≥ (pl. Google Geocoding API).<br/>
        Ha egy c√≠met nem lehet egy√©rtelm≈±en beazonos√≠tani, a sor <i>kihagy√°sra</i> ker√ºl.
      </div>
    </details>

    <div id="status" class="foot"></div>
    <div id="results" class="list"></div>
  </div>

<script>
const sleep = ms => new Promise(r => setTimeout(r, ms));

// Haversine formula a t√°vols√°g sz√°m√≠t√°s√°hoz
function haversine(a, b){
  const R = 6371e3; // F√∂ld sugara m√©terben
  const toRad = d => d * Math.PI/180;
  const dPhi = toRad(b.lat - a.lat);
  const dLambda = toRad(b.lon - a.lon);
  const phi1 = toRad(a.lat);
  const phi2 = toRad(b.lat);
  const s = Math.sin(dPhi/2)**2 + Math.cos(phi1)*Math.cos(phi2)*Math.sin(dLambda/2)**2;
  return 2*R*Math.asin(Math.sqrt(s)); // m√©terben
}

// Egy c√≠m geok√≥dol√°sa
async function geocodeOne(query){
  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", query);
  url.searchParams.set("format", "json");
  url.searchParams.set("limit", "1");
  url.searchParams.set("addressdetails", "1");
  
  const resp = await fetch(url, {
    headers: { 
      "Accept": "application/json",
      "User-Agent": "courier-route-app/1.0 (personal-use)" 
    }
  });
  
  if(!resp.ok) throw new Error("H√°l√≥zati hiba a geok√≥dol√°skor");
  const data = await resp.json();
  if(!data || !data[0]) return null;
  
  return {
    display: data[0].display_name,
    lat: parseFloat(data[0].lat),
    lon: parseFloat(data[0].lon)
  };
}

// √ñsszes c√≠m geok√≥dol√°sa
async function geocodeAll(lines, setStatus){
  const out = [];
  for(let i=0; i<lines.length; i++){
    const q = lines[i].trim();
    if(!q) continue;
    
    setStatus(`Geok√≥dol√°s (${i+1}/${lines.length})‚Ä¶`, 'loading');
    
    try{
      const g = await geocodeOne(q);
      if(g) {
        out.push({ input: q, ...g });
      } else {
        console.warn(`Nem tal√°lhat√≥ c√≠m: ${q}`);
      }
    } catch(e) {
      console.warn("Geok√≥dol√°s hiba:", e);
    }
    
    // Udvarias throttling - 1 m√°sodperc v√°rakoz√°s
    if(i < lines.length - 1) {
      await sleep(1000);
    }
  }
  return out;
}

// Rendez√©s t√°vols√°g szerint
function orderByNearestFromOrigin(origin, points){
  return points
    .map(p => ({...p, dist: haversine(origin, p)}))
    .sort((a,b) => a.dist - b.dist);
}

// Greedy algoritmus: mindig a legk√∂zelebbi k√∂vetkez≈ë pont
function greedyRoute(origin, points){
  const remain = points.slice();
  const route = [];
  let cur = { ...origin };
  
  while(remain.length){
    let bestIdx = 0, bestD = Infinity;
    for(let i=0; i<remain.length; i++){
      const d = haversine(cur, remain[i]);
      if(d < bestD){ 
        bestD = d; 
        bestIdx = i; 
      }
    }
    
    const nextPoint = remain[bestIdx];
    nextPoint.dist = haversine(origin, nextPoint);
    route.push(nextPoint);
    cur = remain[bestIdx];
    remain.splice(bestIdx, 1);
  }
  
  return route;
}

// T√°vols√°g form√°z√°sa
function fmtMeters(m){
  if(m < 1000) return Math.round(m) + " m";
  return (m/1000).toFixed(1).replace(".", ",") + " km";
}

// Apple Maps t√∂bb meg√°ll√≥val ‚Äì Unified Map URL
function appleMultiLink(origin, destinations){
  if(!destinations || !destinations.length) return null;
  const originStr = `${origin.lat},${origin.lon}`;
  const destinationStr = `${destinations[destinations.length-1].lat},${destinations[destinations.length-1].lon}`;
  const u = new URL("https://maps.apple.com/");
  u.searchParams.set("dir", "driving");
  u.searchParams.set("origin", originStr);
  u.searchParams.set("destination", destinationStr);
  if(destinations.length > 1){
    const mids = destinations.slice(0, -1);
    for(const p of mids){
      u.searchParams.append("waypoint", `${p.lat},${p.lon}`);
    }
  }
  return u.toString();
}

// Apple Maps link gener√°l√°sa (1 c√©lpont)
function appleLink(origin, destination){
  if(!destination) return null;
  const d = encodeURIComponent(`${destination.lat},${destination.lon}`);
  const o = encodeURIComponent(`${origin.lat},${origin.lon}`);
  return `https://maps.apple.com/?saddr=${o}&daddr=${d}`;
}

// Google Maps link gener√°l√°sa
function googleLink(origin, destinations){
  if(!destinations.length) return null;
  
  const o = `${origin.lat},${origin.lon}`;
  const dest = `${destinations[destinations.length-1].lat},${destinations[destinations.length-1].lon}`;
  
  let url;
  if(destinations.length === 1) {
    // Egy c√©lpont eset√©n
    url = new URL("https://www.google.com/maps/dir/");
    url.searchParams.set("api", "1");
    url.searchParams.set("origin", o);
    url.searchParams.set("destination", dest);
  } else {
    // T√∂bb c√©lpont eset√©n
    const waypoints = destinations.slice(0, destinations.length-1)
      .map(p => `${p.lat},${p.lon}`).join("|");
    
    url = new URL("https://www.google.com/maps/dir/");
    url.searchParams.set("api", "1");
    url.searchParams.set("origin", o);
    url.searchParams.set("destination", dest);
    if(waypoints) url.searchParams.set("waypoints", waypoints);
  }
  
  return url.toString();
}

// Waze link gener√°l√°sa
function wazeLink(origin, destination){
  if(!destination) return null;
  const ll = `${destination.lat},${destination.lon}`;
  return `https://waze.com/ul?ll=${encodeURIComponent(ll)}&navigate=yes`;
}

// Eredm√©nyek megjelen√≠t√©se
function renderList(container, origin, ordered){
  container.innerHTML = "";
  
  if(!ordered.length) return;
  
  // Teljes √∫tvonal gomb (ha t√∂bb mint 1 c√≠m van)
  if(ordered.length >= 2){
    const allCard = document.createElement("div");
    allCard.className = "card";
    
    const left = document.createElement("div");
    left.innerHTML = "<div class='addr'>üó∫Ô∏è Teljes √∫tvonal</div><div class='muted'>√ñsszes meg√°ll√≥ egyben</div>";
    
    const right = document.createElement("div");
    right.className = "right";
    
    const gAll = document.createElement("a");
    gAll.className = "btn";
    gAll.textContent = "Google Maps";
    gAll.href = googleLink(origin, ordered);
    gAll.target = "_blank";

    // √öJ: Apple Maps t√∂bb meg√°ll√≥val
    const aAll = document.createElement("a");
    aAll.className = "btn secondary";
    aAll.textContent = "Apple Maps";
    aAll.href = appleMultiLink(origin, ordered);
    aAll.target = "_blank";
    
    right.appendChild(gAll);
    right.appendChild(aAll);
    allCard.appendChild(left);
    allCard.appendChild(right);
    container.appendChild(allCard);
  }
  
  // Egyedi c√≠mek
  ordered.forEach((p, idx) => {
    const dist = p.dist || haversine(origin, p);
    const card = document.createElement("div");
    card.className = "card";
    
    const left = document.createElement("div");
    const title = document.createElement("div");
    title.className = "addr";
    title.textContent = `${idx+1}. ${p.input}`;
    
    const sub = document.createElement("div");
    sub.className = "muted";
    sub.textContent = `${fmtMeters(dist)} ‚Ä¢ ${p.display.split(',').slice(0,2).join(',')}`;
    
    left.appendChild(title);
    left.appendChild(sub);
    
    const right = document.createElement("div");
    right.className = "right";
    
    const gBtn = document.createElement("a");
    gBtn.className = "btn secondary";
    gBtn.textContent = "Google";
    gBtn.href = googleLink(origin, [p]);
    gBtn.target = "_blank";
    
    const aBtn = document.createElement("a");
    aBtn.className = "btn ghost";
    aBtn.textContent = "Apple";
    aBtn.href = appleLink(origin, p);
    aBtn.target = "_blank";
    
    const wBtn = document.createElement("a");
    wBtn.className = "btn ghost";
    wBtn.textContent = "Waze";
    wBtn.href = wazeLink(origin, p);
    wBtn.target = "_blank";
    
    right.appendChild(gBtn);
    right.appendChild(aBtn);
    right.appendChild(wBtn);
    
    card.appendChild(left);
    card.appendChild(right);
    container.appendChild(card);
  });
}

// St√°tusz be√°ll√≠t√°sa
function setStatus(message, type = 'info') {
  const status = document.getElementById("status");
  status.textContent = message;
  status.className = `foot ${type}`;
}

// F≈ëfunkci√≥
async function main(){
  const results = document.getElementById("results");
  
  document.getElementById("go").addEventListener("click", async () => {
    const goBtn = document.getElementById("go");
    goBtn.disabled = true;
    goBtn.textContent = "Feldolgoz√°s...";
    
    try {
      results.innerHTML = "";
      setStatus("Helyzet lek√©r√©se‚Ä¶", 'loading');
      
      let origin;
      try {
        origin = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            position => resolve({ 
              lat: position.coords.latitude, 
              lon: position.coords.longitude 
            }),
            error => reject(error),
            { 
              enableHighAccuracy: true, 
              timeout: 15000,
              maximumAge: 60000 
            }
          );
        });
      } catch(e) {
        setStatus("Nem siker√ºlt lek√©rni a helyzetet. Enged√©lyezd a helymeghat√°roz√°st a b√∂ng√©sz≈ëben.", 'error');
        return;
      }
      
      setStatus("C√≠mek feldolgoz√°sa‚Ä¶", 'loading');
      const lines = document.getElementById("addresses").value
        .split("\n")
        .map(s => s.trim())
        .filter(Boolean);
      
      if(!lines.length) { 
        setStatus("Adj meg legal√°bb egy c√≠met.", 'error'); 
        return; 
      }
      
      const geocoded = await geocodeAll(lines, setStatus);
      
      if(!geocoded.length) { 
        setStatus("Egy c√≠met sem siker√ºlt beazonos√≠tani.", 'error'); 
        return; 
      }
      
    const ordered = bruteForceTSP(geocoded, origin);

      
      setStatus(`K√©sz! ${ordered.length} c√≠m rendezve a ${geocoded.length !== lines.length ? `${lines.length} k√∂z√ºl` : 'list√°b√≥l'}.`, 'success');
      renderList(results, origin, ordered);
      
      // Automatikus navig√°ci√≥ megnyit√°sa
      const app = document.getElementById("app").value;
      let href = null;
      
      if(app === "google") {
        href = googleLink(origin, ordered);
      } else if(app === "apple") {
        // Apple Maps t√∂bb meg√°ll√≥val (Unified Map URL)
        href = appleMultiLink(origin, ordered);
      } else if(app === "waze") {
        href = wazeLink(origin, ordered[0]);
      }
      
      if(href) {
        window.open(href, "_blank");
      }
      
    } catch(error) {
      console.error("Hiba:", error);
      setStatus("V√°ratlan hiba t√∂rt√©nt. Pr√≥b√°ld √∫jra.", 'error');
    } finally {
      goBtn.disabled = false;
      goBtn.textContent = "Rendez√©s + Navig√°ci√≥";
    }
  });
  
  // P√©lda c√≠mek bet√∂lt√©se
  const exampleAddresses = `Kossuth Lajos utca 5, Szeged
Dugonics t√©r 1, Szeged
R√°k√≥czi √∫t 12, Szeged`;
  
  if(!document.getElementById("addresses").value.trim()) {
    document.getElementById("addresses").value = exampleAddresses;
  }
}

// Alkalmaz√°s ind√≠t√°sa
window.addEventListener('load', main);

// TSP brute force optimaliz√°l√°s
function permute(arr) {
  const results = [];
  function helper(path, remaining) {
    if (remaining.length === 0) {
      results.push(path);
      return;
    }
    for (let i = 0; i < remaining.length; i++) {
      helper(
        path.concat(remaining[i]),
        remaining.slice(0, i).concat(remaining.slice(i + 1))
      );
    }
  }
  helper([], arr);
  return results;
}

function totalDistance(route, points, origin) {
  let dist = 0;
  let cur = origin;
  for (let i = 0; i < route.length; i++) {
    dist += haversine(cur, points[route[i]]);
    cur = points[route[i]];
  }
  return dist;
}

function bruteForceTSP(points, origin) {
  const indices = Array.from({ length: points.length }, (_, i) => i);
  const perms = permute(indices);

  let bestRoute = null;
  let bestDist = Infinity;

  perms.forEach(route => {
    const d = totalDistance(route, points, origin);
    if (d < bestDist) {
      bestDist = d;
      bestRoute = route;
    }
  });

  return bestRoute.map(i => points[i]);
}

  
</script>
</body>
</html>
